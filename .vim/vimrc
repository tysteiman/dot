execute pathogen#infect()
color delek
" Sets {{{ -----------------------

" set t_Co=256
set background=dark
set foldlevelstart=0
syntax on
set number
set magic
set hlsearch
set nocompatible
set foldmethod=marker
set ai
set history=700
set ruler
set cmdheight=1
set hid
set ignorecase
set smartcase
set incsearch
set expandtab
set smarttab
set shiftwidth=4
set tabstop=4
set lbr
set tw=500
set wrap
set noswapfile
set laststatus=0
set autoread
filetype indent on

" }}}
" Snippets {{{ ---------------------------------------------------

" --- Vim {{{-------------------------------

augroup snippets_vim
    autocmd!
    autocmd FileType vim nnoremap <buffer><localleader>ag iaugroup<enter>augroup<space>end<esc>kA<space>
augroup end

" }}}
" --- Javascript {{{-------------------------------

augroup snippets_javascript
    autocmd!
    autocmd FileType javascript inoremap <buffer><localleader>ff for<space>(var i = 0; i < lessthan; i++){<Enter>}<Esc>k0f<wvt;
    autocmd FileType javascript inoremap <buffer><localleader>qq $("")<esc>F"i
    autocmd FileType javascript inoremap <buffer><localleader>qe $()<esc>F)i
    autocmd FileType javascript inoremap <buffer><localleader>dr $(document).ready(function()<space>{<enter><esc>A});<esc>O
    autocmd FileType javascript inoremap <buffer><localleader>qf $().(function()<space>{<enter><esc>A});<esc>k0f)i
    autocmd FileType javascript inoremap <buffer><localleader>cl console.log();<esc>F)i
    autocmd FileType javascript inoremap <buffer><localleader>an ()();<esc>2F)ifunction<space>(){<enter>}<esc>O
    autocmd FileType javascript inoremap <buffer><localleader>ge document.getElementById('#');<esc>F'i
    autocmd FileType javascript inoremap <buffer><localleader>gc document.getElementsByClass('.');<esc>F'i
    autocmd FileType javascript inoremap <buffer><localleader>qp $.post("send_to.php",<space>{data:set}).done(function<space>(data)<space>{<enter>});<esc>k0f"lvi"
    autocmd FileType javascript inoremap <buffer><localleader>qg $.get("get_from.php",<space>{data:set}).done(function<space>(data)<space>{<enter>});<esc>k0f"lvi"
augroup end

" }}}
" --- Ruby {{{-------------------------------

augroup snippets_ruby
    autocmd!
    autocmd FileType ruby iabbrev <buffer>iff if<Enter>end<Enter><Esc>kkA
    autocmd FileType ruby iabbrev <buffer>ife if<Enter>else<Enter>end<Enter><Esc>kkkA
    autocmd FileType ruby,eruby inoremap <buffer><c-b> {\|\|<space>}<esc>F\|i
    autocmd FileType ruby inoremap <buffer><leader>fe <esc>:call RubyEachWithAbbreviation("ruby")<cr>
augroup end

fun! RubyEachWithAbbreviation(type)
    if a:type == "eruby"
        :execute "normal! i\<right>.each\<space>do\<space>||\<space>\<esc>o\<%\<space>end\<space>%>\<esc>k"
    else
        :execute "normal i\<right>.each\<space>do\<space>||\<enter>end\<esc>k"
    endif
    let l:abb = RubyGrabAbbreviation()
    :execute "normal! 2f|i" . l:abb . "\<esc>"
endfun

fun! RubyGrabAbbreviation()
    let l:reg = @"
    :normal! byl
    let l:newreg = @"
    let @" = l:reg
    return l:newreg
endfun

" }}}
" --- ERB {{{-------------------------------

augroup snippets_erb
    autocmd!
    autocmd FileType eruby inoremap <buffer><localleader>= <%=%><esc>F=a<space>
    autocmd FileType eruby inoremap <buffer><localleader>% <%%><esc>F%i<space>
    autocmd FileType eruby inoremap <buffer><localleader>ie <%<space>if<space>%><enter><%<space>else<space>%><enter><%<space>end<space>%><esc>kk$F%i
    autocmd FileType eruby inoremap <buffer><localleader>ii <%<space>if<space>%><enter><%<space>end<space>%><esc>k$F%i
    autocmd FileType eruby inoremap <buffer>fe <esc>:call RubyEachWithAbbreviation("eruby")<cr>
augroup end

" }}}
" --- PHP {{{-------------------------------

augroup snippets_php
    autocmd!
    autocmd FileType php inoremap <buffer><localleader>ff for<space>($i = 0; $i < lessthan; $i++)<space>{<Enter>}<Esc>k0f<wviw
    autocmd FileType php inoremap <buffer><localleader>fe1 foreach<space>($things as $thing)<space>{<Enter>}<Esc>k0f$wviw
    autocmd FileType php inoremap <buffer><localleader>fe2 foreach<space>($things as $key => $value)<space>{<Enter>}<Esc>k0f$wviw
    autocmd FileType php inoremap <buffer><localleader>fa <esc>:call PhpNextArg()<cr>
    autocmd FileType php nnoremap <buffer><localleader>pr mmIprint_r(<esc>f;i)<esc>`m
augroup end

fun! PhpNextArg()
    :normal! f$wviw
endfun

" }}}
" --- Mixed {{{-------------------------------

augroup snippets_mixed
    autocmd!
    autocmd FileType php,cpp,javascript,c,java inoremap<buffer><localleader>ii if () {<Enter>}<Esc>bbf)i
    autocmd FileType php,cpp,javascript,c,java inoremap <buffer><localleader>ie if () {<Enter>} else {<Enter>}<Esc>kk0f)i
    autocmd FileType php,cpp,javascript,c,java inoremap <buffer><localleader>ee <space>else {<Enter>}<Esc>O
    autocmd FileType eruby,ruby inoremap <buffer><localleader>ss #{}<left>
augroup end

" }}}
" --- Commenter {{{-------------------------------

augroup snippets_commenter
    autocmd!
    autocmd FileType vim nnoremap<buffer><localleader>cc :call CommentLines("vim", 0)<cr>
    autocmd FileType html,eruby,liquid nnoremap <buffer><localleader>cc :call CommentLines("html", 1)<cr>
    autocmd FileType html,eruby,liquid vnoremap <buffer><localleader>cc :call CommentLines("html", 0)<cr>
    autocmd FileType javascript,php,java,c,cpp noremap<silent><buffer><localleader>cc :call CommentLines("c", 0)<cr>
    autocmd FileType python,ruby noremap<silent><buffer><localleader>cc :call CommentLines("rb", 0)<cr>
augroup end


fun! CommentLines(ftype, isNormalMode) range
    let l:curline = a:firstline
    let l:exRegister = @"
    :normal! mm
    if a:ftype == "html"
        :normal! ^lyl
        if @" == "!"
            :normal! ^dt<$F>ld$^
        else
            :normal! k^lyl
            if @" == "!"
                :normal! dd`>jdd"
            else
                if a:isNormalMode
                    :execute "normal! jI<!--\<space>\<esc>A\<space>-->\<esc>^"
                else
                    :execute "normal! o<!--\<esc>`>o-->\<esc>"
                endif
            end
        endif
    else
        while l:curline <= a:lastline
            :call cursor(l:curline, 1)
            :normal! ^yl
            let l:fchar = @"
            if a:ftype == "c"
                if l:fchar == "/"
                    :normal! 3x
                else
                    :execute "normal! I//\<space>"
                endif
            elseif a:ftype == "vim"
                if l:fchar == '"'
                    :normal 2x
                else
                    :execute "normal! I\"\<space>"
                endif
            else
                if l:fchar == "#"
                    :normal! 2x
                else
                    :execute "normal! I#\<space>"
                endif
            endif
            let l:curline+=1
        endwhile
    endif
    let @" = l:exRegister
    :normal! `m
    :execute "normal! :w\<esc>"
endfun

" }}}

" }}}
" Mappings {{{ -------------------------------------------------------

" --- operators {{{-------------------------------

onoremap p i(
onoremap in :<c-u>normal! f(vi(<cr>
onoremap il :<c-u>normal! F)vi(<cr>
onoremap fn :<c-u>normal! 0f(hviw<CR>
onoremap ih :<c-u>execute "normal! ?^==\\+$\r:nohlsearch\rkvg_"<cr>

" }}}
" --- insert {{{-------------------------------

inoremap jk <esc>
inoremap <c-\>a <esc>A
inoremap <c-\>i <esc>I
inoremap <c-\>q ("")<esc><left>i
inoremap <c-\>; <esc>mmA;<esc>`mi<right>

" }}}
" --- normal {{{-------------------------------

nnoremap <leader>" viw<esc>a"<esc>hbi"<esc>lel
nnoremap <leader>' viw<esc>a'<esc>hbi'<esc>lel
nnoremap <leader>ev :vsplit $MYVIMRC<cr>
nnoremap <leader>B :Gblame<cr>
nnoremap <leader>vv :e $MYVIMRC<cr>
nnoremap <silent> <c-k> :wincmd k<CR>
nnoremap <silent> <c-j> :wincmd j<CR>
nnoremap <silent> <c-h> :wincmd h<CR>
nnoremap <silent> <c-l> :wincmd l<CR>
nnoremap <leader>l1 yyp0vg_r=o<Enter>
nnoremap <leader>l2 yyp0vg_r-o<Enter>
nnoremap <silent><leader>g :Gst<cr>
nnoremap <leader>+ 10<c-w>+
nnoremap <leader>> 10<c-w>> -->
nnoremap <leader>< 10<c-w><
nnoremap <leader>sv :source %<CR>:noh<cr>
nnoremap <leader>vs :!vimsync<cr>
nnoremap <leader>o O<esc>jo<esc>k
nnoremap <leader>sp mm[s1z=`m
nnoremap <leader>lb :execute "rightbelow vsplit " . bufname("#")<cr>
nnoremap <leader>; mmA;<esc>`m
nnoremap <leader>Q :call QuickFixToggle()<cr>
nnoremap <silent><leader>2 :NumbersToggle<CR>
nnoremap <silent><leader>a :spellr<CR>
nnoremap <silent><leader>b :TagbarToggle<CR>
nnoremap <silent><leader>q :bp<bar>sp<bar>bn<bar>bd<CR>
nnoremap <silent><leader>t :tselect<CR>
nnoremap <leader>w :StripWhitespace<CR>
" nnoremap <silent><C-n> :NERDTreeToggle<CR>

let g:quickfix_is_open = 0
function! QuickFixToggle()
    if g:quickfix_is_open
        cclose
        let g:quickfix_is_open = 0
        execute g:quickfix_return_to_window . "wincmd w"
    else
        let g:quickfix_return_to_window = winnr()
        copen
        let g:quickfix_is_open = 1
    endif
endfunction

" }}}
" --- visual {{{-------------------------------

vnoremap <leader>: <esc>`<i"<esc>`>la"<esc>
vnoremap <leader>; <esc>`<i'<esc>`>la'<esc>

" }}}

" }}}
" Abbreviations {{{ ----------

iabbrev teh the
iabbrev iot in order to
iabbrev doc documentation

" }}}
" Status Line {{{ -----------------

fun! GetGitBranch()
    let l:br = system("git branch | grep '* ' | sed 's.* ..'")
    if l:br[0:5] != "fatal:"
        return substitute(l:br, '\n', '', 'g')
    else
        return 'X'
    endif
endfun

set statusline=%r
set statusline+=%t
set statusline+=\ ->\ %y
set statusline+=%m
set statusline+=\ \ Buffer:[%n]
" set statusline+=\ \ Git:[%{GetGitBranch()}]
set statusline+=%=
set statusline+=Line:[
set statusline+=%l
set statusline+=/
set statusline+=%L
set statusline+=]
set statusline+=\ \ Col:[%c]

" }}}
" Plugin Variables{{{-------------------------------

let g:numbers_exclude = ["tagbar","minibufexpl","nerdtree", "fugitive"]

" }}}
" V Search {{{-------------------------------

function! VisualStarSearchSet(cmdtype,...)
    let temp = @"
    normal! gvy
    if !a:0 || a:1 != 'raw'
        let @" = escape(@", a:cmdtype.'\*')
    endif
    let @/ = substitute(@", '\n', '\\n', 'g')
    let @/ = substitute(@/, '\[', '\\[', 'g')
    let @/ = substitute(@/, '\~', '\\~', 'g')
    let @" = temp
endfunction

" replace vim's built-in visual * and # behavior
xnoremap * :<C-u>call VisualStarSearchSet('/')<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call VisualStarSearchSet('?')<CR>?<C-R>=@/<CR><CR>

" recursively vimgrep for word under cursor or selection
if maparg('<leader>*', 'n') == ''
    nnoremap <leader>* :execute 'noautocmd vimgrep /\V' . substitute(escape(expand("<cword>"), '\'), '\n', '\\n', 'g') . '/ **'<CR>
endif
if maparg('<leader>*', 'v') == ''
    vnoremap <leader>* :<C-u>call VisualStarSearchSet('/')<CR>:execute 'noautocmd vimgrep /' . @/ . '/ **'<CR>
endif

" }}}
" folding bindings (messes up file when declaring them) {{{

autocmd FileType vim inoremap <buffer><localleader>fo {{{<enter><enter><enter><enter>}}}<esc>I"<space><esc>?{{{<cr>I"<space>
autocmd FileType php,javascript,cpp,c,java inoremap <buffer><localleader>fo {{{<enter><enter><enter><enter>}}}<esc>I//<space><esc>?{{{<cr>I//<space>
autocmd FileType ruby,python inoremap <buffer><localleader>fo {{{<enter><enter><enter><enter>}}}<esc>I#<space><esc>?{{{<cr>I#<space>

" }}}

